/*****************************************************************************
 * General TrickHLA Simulation Base Class Definition Object
 *---------------------------------------------------------------------------*
 * PURPOSE:
 *    (This is a Simulation Definition 'S_define' module that defines a
 *     general HLA interface using TrickHLA for Trick based simulations.)
 ****************************************************************************/
/*****************************************************************************
 *       Author: Dan E. Dexter
 *         Date: August 2010
 *       E-Mail: Dan.E.Dexter@nasa.gov
 *        Phone: 281-483-1142
 * Organization: Mail Code ER7
 *               Simulation & Graphics Branch
 *               Software, Robotics & Simulation Division
 *               2101 NASA Parkway
 *               Houston, Texas 77058
 *---------------------------------------------------------------------------*
 * Modified By: Edwin Z. Crues
 *        Date: April 2020
 * Description: Modified THLA.sm to create THLABase.sm to support
 *              ExecutionControl extensions.
 *---------------------------------------------------------------------------*
 * Modified By: Dan Dexter
 *        Date: May 2021
 * Description: Modified THLABase.sm to work with THLAThread.sm to support
 *              TrickHLA working with HLA data processed across different
 *              Trick child threads.
 ****************************************************************************/

// Trick include files.
##include "trick/exec_proto.h"

// TrickHLA include files.
##include "TrickHLA/FedAmb.hh"
##include "TrickHLA/Federate.hh"
##include "TrickHLA/Manager.hh"

// Include these TrickHLA header files here so that Trick can find and process
// these forward declared classes because they are also not included by any
// TrickHLA header file. Otherwise the autogenerated Trick ATTRIBUTES named
// <namespace>__<classname> (e.g. TrickHLA__Interaction) will not get
// created because Trick can't figure out the header file dependencies for
// these header files.
##include "TrickHLA/Interaction.hh"
##include "TrickHLA/InteractionHandler.hh"
##include "TrickHLA/InteractionItem.hh"
##include "TrickHLA/LagCompensation.hh"
##include "TrickHLA/ObjectDeleted.hh"
##include "TrickHLA/OwnershipHandler.hh"
##include "TrickHLA/Parameter.hh"
##include "TrickHLA/ParameterItem.hh"

//=========================================================================
// SIM_OBJECT: THLABase - Generalized TrickHLA interface routines.
//=========================================================================
class THLABaseSimObject : public Trick::SimObject {

 public:

   //----- DATA STRUCTURE DECLARATIONS -----
   TrickHLA::Federate federate;
   TrickHLA::FedAmb   federate_amb;
   TrickHLA::Manager  manager;

   THLABaseSimObject( double data_cycle,
                      double interaction_cycle,
                      unsigned short _1ST  = 1,
                      unsigned short _INIT = 60,
                      unsigned short _LAST = 65534 )
      : data_cycle_time( data_cycle )
   {
      // Validate the data and interaction cycle times.
      if ( data_cycle <= 0.0 ) {
         exec_terminate( __FILE__, "THLABaseSimObject() data_cycle must be > 0.0!" );
      }
      if ( interaction_cycle <= 0.0 ) {
         exec_terminate( __FILE__, "THLABaseSimObject() interaction_cycle must be > 0.0!" );
      }

      //-----------------------
      //-- DEFAULT DATA JOBS --
      //-----------------------

      //-------------------------
      //-- INITIALIZATION JOBS --
      //-------------------------

      // Initialize the debug settings just after the Input Processor runs as
      // the first job so the debug settings are available and valid.
      P1 ("initialization") federate.initialize_debug();

      // Initialize thread state memory associated with the Trick child
      // threads. Also configure the Trick main thread HLA delta time step,
      // which is the HLA time advancement and data cycle time.
      P1 ("initialization") federate.initialize_thread_state( data_cycle_time );

      // After all the P2 jobs run in the THLAThreadSimObject sim-object to
      // assoicate Trick child threads to object instances, verify all the
      // thread associations.
      P3 ("initialization") federate.verify_trick_child_thread_associations();

      // Setup the HLA infrastructure.
      P_INIT ("initialization") federate.initialize();

      // This begins the process of standing up the federate in the federation
      // execution. This preforms all the startup steps prior to any
      // multi-phase inializtation process defined by the user. The multi-
      // phase inialization will be performed as initialization jobs between
      // P_INIT and P_LAST.
      P_INIT ("initialization") federate.pre_multiphase_initialization();

      // The last step of the multi-phase initialization. We make sure this
      // initialization job runs last by setting the initialization phase
      // to the last phase, since this job indicates to the other federates
      // that we are ready to start running the simulation.
      P_LAST ("initialization") federate.post_multiphase_initialization();

      //------------------------------
      //-- FREEZE / CHECKPOINT JOBS --
      //------------------------------

      // Perform the federate save (checkpoint) or restore in FREEZE mode.
      P_1ST  ("checkpoint") federate.setup_checkpoint();
      P60000 ("freeze") federate.perform_checkpoint();
      P_1ST  ("preload_checkpoint") federate.setup_restore();
      P60000 ("freeze") federate.perform_restore();

      // Handle federates going to freeze mode.
      P_1ST ("freeze_init") federate.freeze_init();
      P_1ST ("freeze") federate.check_freeze();

      // Coordinate federates going to run mode as the last unfreeze job.
      P65535 ("unfreeze") federate.exit_freeze();

      //--------------------
      //-- SCHEDULED JOBS --
      //--------------------

      // Wait for the Time Advance Grant (TAG).
      P_1ST (data_cycle, "environment") federate.wait_for_time_advance_grant();

      // Process all interactions that were received.
      P_1ST (interaction_cycle, "environment") manager.process_interactions();

      // Process any deleted objects.
      P_1ST (data_cycle, "environment") manager.process_deleted_objects();

      // Grab any new cyclic data from the other Federates that has arrived
      // and update the local state. (This is done down here to make sure we
      // do the copying AFTER the event loop has fired the reflect call-backs.)
      P_1ST (data_cycle, "environment") manager.receive_cyclic_data();

      // Annouce to the Trick child threads the data is available.
      P_1ST (data_cycle, "environment") federate.announce_data_available();

      // Wait to send the data when all child threads are ready.
      P_LAST (data_cycle, "logging") federate.wait_to_send_data();

      // Send any new cyclic and requeted data. Requested data would occur as
      // the result of another federate requesting an attribute value update.
      P_LAST (data_cycle, "logging") manager.send_cyclic_and_requested_data();

      // Process the ownership requests.
      P_LAST (data_cycle, "logging") manager.process_ownership();

      // Announce to the Trick child threads the data was sent.
      P_LAST (data_cycle, "logging") federate.announce_data_sent();

      // Request to go to the next logical time step with a HLA
      // Time-Advance-Request (TAR).
      P_LAST (data_cycle, "logging") federate.time_advance_request();

      // Coordinate federates going to freeze mode.
      P_LAST ("end_of_frame") federate.enter_freeze();

      //-------------------
      //-- SHUTDOWN JOBS --
      //-------------------
      P_LAST ("shutdown") federate.shutdown();
   }

   // Pure virtual destructor. Make this SimObject an abstract class.
   // It must be extended with a specific ExecutionControl implementation.
   virtual ~THLABaseSimObject() = 0;

 protected:
   double data_cycle_time;

 private:
   // Do not allow the implicit copy constructor or assignment operator.
   THLABaseSimObject( THLABaseSimObject const & rhs );
   THLABaseSimObject & operator=( THLABaseSimObject const & rhs );

   // Do not allow the default constructor.
   THLABaseSimObject();
};

// Required implementation of the pure virtual destructor.
%{
   THLABaseSimObject::~THLABaseSimObject(){}
%}

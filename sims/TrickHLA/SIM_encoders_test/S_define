
#include "sim_objects/default_trick_sys.sm"

##include "TrickHLA/Manager.hh"

##include "TrickHLA/encoding/EncoderFactory.hh"
##include "TrickHLA/encoding/EncoderBase.hh"

##include "encoding/include/EncodingTest.hh"
##include "encoding/include/Float32Data.hh"
##include "encoding/include/Float64Data.hh"
##include "encoding/include/CharData.hh"
##include "encoding/include/Int16Data.hh"
##include "encoding/include/Int32Data.hh"
##include "encoding/include/Int64Data.hh"
##include "encoding/include/LongData.hh"
##include "encoding/include/StringData.hh"

%header{
 using namespace TrickHLA;
 using namespace TrickHLAModel;
%}


//=============================================================================
// SIM_OBJECT: TestSimObj
// Sim-object for testing basic data type encoders.
//=============================================================================
class TestSimObj : public Trick::SimObject {

 public:
   CharData char_data1 = CharData( 0 );
   CharData char_data2 = CharData( 10 );

   StringData string_data1 = StringData( 0 );
   StringData string_data2 = StringData( 10 );

   Int16Data int16_data1 = Int16Data( 0 );
   Int16Data int16_data2 = Int16Data( 0 );

   Int32Data int32_data1 = Int32Data( 0 );
   Int32Data int32_data2 = Int32Data( 10 );

   Int64Data int64_data1 = Int64Data( 10 );
   Int64Data int64_data2 = Int64Data( 0 );

   LongData long_data1 = LongData( 0 );
   LongData long_data2 = LongData( 10 );

   Float32Data float32_data1 = Float32Data( 0 );
   Float32Data float32_data2 = Float32Data( 10 );

   Float64Data float64_data1 = Float64Data( 10 );
   Float64Data float64_data2 = Float64Data( 0 );

   EncodingTest encoder_test;

   bool const verbose = false;

   TestSimObj()
   {
      ("initialization") encoder_test.char_test( "T.char_data1", char_data1,
                                                 "T.char_data2", char_data2,
                                                 verbose );
#if 0
      ("initialization") encoder_test.string_test( "T.string_data1", string_data1,
                                                   "T.string_data2", string_data2,
                                                    true );
#endif
      ("initialization") encoder_test.int16_test( "T.int16_data1", int16_data1,
                                                  "T.int16_data2", int16_data2,
                                                  verbose );

      ("initialization") encoder_test.int32_test( "T.int32_data1", int32_data1,
                                                  "T.int32_data2", int32_data2,
                                                  verbose );

      ("initialization") encoder_test.int64_test( "T.int64_data1", int64_data1,
                                                  "T.int64_data2", int64_data2,
                                                  verbose );

      ("initialization") encoder_test.long_test( "T.long_data1", long_data1,
                                                 "T.long_data2", long_data2,
                                                 verbose );

      ("initialization") encoder_test.float32_test( "T.float32_data1", float32_data1,
                                                    "T.float32_data2", float32_data2,
                                                    verbose );

      ("initialization") encoder_test.float64_test( "T.float64_data1", float64_data1,
                                                    "T.float64_data2", float64_data2,
                                                    verbose );

      ("initialization") exec_terminate( __FILE__, "Done" );
   }

 private:
   // Do not allow the implicit copy constructor or assignment operator.
   TestSimObj( TestSimObj const & rhs );
   TestSimObj & operator=( TestSimObj const & rhs );
};

TestSimObj T;
